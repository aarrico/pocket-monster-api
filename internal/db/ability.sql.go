// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: ability.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAbility = `-- name: CreateAbility :one
INSERT INTO ability
    (name, effect)
VALUES ($1, $2)
RETURNING id
`

type CreateAbilityParams struct {
	Name   string
	Effect string
}

func (q *Queries) CreateAbility(ctx context.Context, arg CreateAbilityParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createAbility, arg.Name, arg.Effect)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const getAbilitiesForPokemon = `-- name: GetAbilitiesForPokemon :many
SELECT a.id, a.name, a.effect, pa.slot, pa.is_hidden
FROM ability AS a
         INNER JOIN pokemon_ability pa ON a.id = pa.ability_id
WHERE pa.pokemon_id = $1
ORDER BY pa.slot
`

type GetAbilitiesForPokemonRow struct {
	ID       pgtype.UUID
	Name     string
	Effect   string
	Slot     int32
	IsHidden bool
}

func (q *Queries) GetAbilitiesForPokemon(ctx context.Context, pokemonID pgtype.UUID) ([]GetAbilitiesForPokemonRow, error) {
	rows, err := q.db.Query(ctx, getAbilitiesForPokemon, pokemonID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAbilitiesForPokemonRow
	for rows.Next() {
		var i GetAbilitiesForPokemonRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Effect,
			&i.Slot,
			&i.IsHidden,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAbilitiesForPokemonByDexOrder = `-- name: GetAbilitiesForPokemonByDexOrder :many
SELECT a.id, a.name, a.effect, pa.slot, pa.is_hidden
FROM ability AS a
         INNER JOIN pokemon_ability pa ON a.id = pa.ability_id
         INNER JOIN pokemon p ON pa.pokemon_id = p.id
WHERE p.national_dex_order = $1
ORDER BY pa.slot
`

type GetAbilitiesForPokemonByDexOrderRow struct {
	ID       pgtype.UUID
	Name     string
	Effect   string
	Slot     int32
	IsHidden bool
}

func (q *Queries) GetAbilitiesForPokemonByDexOrder(ctx context.Context, nationalDexOrder int32) ([]GetAbilitiesForPokemonByDexOrderRow, error) {
	rows, err := q.db.Query(ctx, getAbilitiesForPokemonByDexOrder, nationalDexOrder)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAbilitiesForPokemonByDexOrderRow
	for rows.Next() {
		var i GetAbilitiesForPokemonByDexOrderRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Effect,
			&i.Slot,
			&i.IsHidden,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAbility = `-- name: GetAbility :one
SELECT id, name, effect
from ability
where id = $1
`

func (q *Queries) GetAbility(ctx context.Context, id pgtype.UUID) (Ability, error) {
	row := q.db.QueryRow(ctx, getAbility, id)
	var i Ability
	err := row.Scan(&i.ID, &i.Name, &i.Effect)
	return i, err
}

const getAbilityByName = `-- name: GetAbilityByName :one
SELECT id, name, effect
from ability
where name = $1
`

func (q *Queries) GetAbilityByName(ctx context.Context, name string) (Ability, error) {
	row := q.db.QueryRow(ctx, getAbilityByName, name)
	var i Ability
	err := row.Scan(&i.ID, &i.Name, &i.Effect)
	return i, err
}

const setPokemonAbilityRelation = `-- name: SetPokemonAbilityRelation :exec
INSERT INTO pokemon_ability
    (pokemon_id, ability_id, slot, is_hidden)
VALUES ($1, $2, $3, $4)
`

type SetPokemonAbilityRelationParams struct {
	PokemonID pgtype.UUID
	AbilityID pgtype.UUID
	Slot      int32
	IsHidden  bool
}

func (q *Queries) SetPokemonAbilityRelation(ctx context.Context, arg SetPokemonAbilityRelationParams) error {
	_, err := q.db.Exec(ctx, setPokemonAbilityRelation,
		arg.PokemonID,
		arg.AbilityID,
		arg.Slot,
		arg.IsHidden,
	)
	return err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: type.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getMultiplierById = `-- name: GetMultiplierById :one
SELECT multiplier
FROM type_effectiveness
WHERE attacking_type_id = $1 AND defending_type_id = $2
`

type GetMultiplierByIdParams struct {
	AttackingTypeID int32
	DefendingTypeID int32
}

func (q *Queries) GetMultiplierById(ctx context.Context, arg GetMultiplierByIdParams) (pgtype.Numeric, error) {
	row := q.db.QueryRow(ctx, getMultiplierById, arg.AttackingTypeID, arg.DefendingTypeID)
	var multiplier pgtype.Numeric
	err := row.Scan(&multiplier)
	return multiplier, err
}

const getMultiplierByName = `-- name: GetMultiplierByName :one
SELECT te.multiplier
FROM type_effectiveness as te
JOIN type at on te.attacking_type_id = at.id
JOIN type dt on te.defending_type_id = dt.id
WHERE at.name = $1 AND dt.name = $2
`

type GetMultiplierByNameParams struct {
	Name   string
	Name_2 string
}

func (q *Queries) GetMultiplierByName(ctx context.Context, arg GetMultiplierByNameParams) (pgtype.Numeric, error) {
	row := q.db.QueryRow(ctx, getMultiplierByName, arg.Name, arg.Name_2)
	var multiplier pgtype.Numeric
	err := row.Scan(&multiplier)
	return multiplier, err
}

const getTypeByName = `-- name: GetTypeByName :one
SELECT id FROM type WHERE name = $1
`

func (q *Queries) GetTypeByName(ctx context.Context, name string) (int32, error) {
	row := q.db.QueryRow(ctx, getTypeByName, name)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const listTypes = `-- name: ListTypes :many
SELECT id, name FROM type
`

func (q *Queries) ListTypes(ctx context.Context) ([]Type, error) {
	rows, err := q.db.Query(ctx, listTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Type
	for rows.Next() {
		var i Type
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
